name: CI/CD Pipeline (PM2 Zero Downtime Deployment)

on:
  push:
    branches: [production, staging, feat/cicd]
  pull_request:
    branches: [production, staging, feat/cicd]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: false

env:
  SERVICE_NAME: backend
  CI_USER: logicrays
  DEPLOY_PATH: /home/logicrays/deployments
  ENV_PATH: /home/logicrays/environments

jobs:
  test:
    runs-on: ubuntu-latest
    concurrency:
      group: test-${{ github.ref }}
      cancel-in-progress: true

    env:
      TEST_DB_USER: postgres
      TEST_DB_PASSWORD: postgres
      TEST_DB_PORT: 5432
      CLEAN_TEST_DB: test_db_clean
      SNAPSHOT_DB: snapshot_${{ github.ref == 'refs/heads/production' && 'prod' || github.ref == 'refs/heads/staging' && 'staging' || 'dev' }}

    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: postgres
          POSTGRES_PASSWORD: postgres
          POSTGRES_DB: postgres
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - uses: actions/checkout@v4

      - name: Install SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Set environment variables
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            echo "APP_PORT=5000" >> $GITHUB_ENV
          elif [[ ${{ github.ref }} == 'refs/heads/staging' ]]; then
            echo "ENVIRONMENT=staging" >> $GITHUB_ENV
            echo "APP_PORT=5001" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            echo "APP_PORT=5001" >> $GITHUB_ENV
          fi

      - name: Phase 1 - Clean Database Tests
        run: |
          echo "Running tests against clean database..."

          # Create clean test database
          # PGPASSWORD=${{ env.TEST_DB_PASSWORD }} psql -h localhost -U ${{ env.TEST_DB_USER }} -d postgres -c "CREATE DATABASE ${{ env.CLEAN_TEST_DB }};"

          DATABASE_URL="postgresql://${{ env.TEST_DB_USER }}:${{ env.TEST_DB_PASSWORD }}@localhost:${{ env.TEST_DB_PORT }}/${{ env.CLEAN_TEST_DB }}"

          # Run migrations on clean database without seeding
          # Set SKIP_SEED=true to prevent automatic seeding during migration
          DATABASE_URL=$DATABASE_URL SKIP_SEED=true npx prisma migrate deploy
          DATABASE_URL=$DATABASE_URL npx prisma generate

          # Run tests against clean database
          DATABASE_URL=$DATABASE_URL npm run test:e2e

          echo "Clean database tests passed!"

      - name: Phase 2 - Setup Snapshot Database
        id: snapshot
        run: |
          # Set the source and snapshot database URLs based on the branch
          if [[ "${{ github.ref }}" == "refs/heads/production" ]]; then
            SOURCE_DB_URL="${{ secrets.PROD_DATABASE_URL }}"
            SNAPSHOT_DB="snapshot_prod"
          else
            SOURCE_DB_URL="${{ secrets.STAGING_DATABASE_URL }}"
            SNAPSHOT_DB="snapshot_staging"
          fi

          # Extract base URL without query parameters and database name
          CLEAN_DB_URL=$(echo "$SOURCE_DB_URL" | cut -d "?" -f1)
          BASE_URL=$(dirname "$CLEAN_DB_URL")
          SOURCE_DB=$(basename "$CLEAN_DB_URL")

          echo "Creating snapshot database: $SNAPSHOT_DB"

          # Create the snapshot database
          psql "$SOURCE_DB_URL" -c "
            SELECT pg_terminate_backend(pid)
            FROM pg_stat_activity
            WHERE datname = '$SNAPSHOT_DB' AND pid <> pg_backend_pid();
          "

          echo "Dropping existing snapshot if it exists..."
          psql "$SOURCE_DB_URL" -c "DROP DATABASE IF EXISTS $SNAPSHOT_DB;"

          echo "Creating new snapshot from $SOURCE_DB..."
          psql "$SOURCE_DB_URL" -c "CREATE DATABASE $SNAPSHOT_DB WITH TEMPLATE $SOURCE_DB;"

          # Construct the snapshot database URL
          SNAPSHOT_DB_URL="${BASE_URL}/${SNAPSHOT_DB}"

          echo "SNAPSHOT_DB_URL=$SNAPSHOT_DB_URL" >> "$GITHUB_ENV"
          echo "Snapshot database created successfully at: $SNAPSHOT_DB_URL"

      - name: Phase 2 - Run Tests Against Snapshot Database
        run: |
          echo "Running tests against production-like database..."

          # Run migrations on snapshot database
          DATABASE_URL="${{ env.SNAPSHOT_DB_URL }}" npx prisma migrate deploy

          # Generate Prisma client
          DATABASE_URL="${{ env.SNAPSHOT_DB_URL }}" npx prisma generate

          # Run tests against snapshot database
          # DATABASE_URL="${{ env.SNAPSHOT_DB_URL }}" npm run test:e2e

          echo "Production-like database tests passed!"
        env:
          NODE_ENV: test
          PORT: ${{ env.APP_PORT }}
          HOST: localhost
          JWT_ACCESS_TOKEN_SECRET: test_jwt_secret
          JWT_REFRESH_TOKEN_SECRET: test_refresh_secret
          JWT_RESET_TOKEN_SECRET: test_reset_secret
          JWT_ACCESS_TOKEN_EXPIRES_IN: 1h
          JWT_REFRESH_TOKEN_EXPIRES_IN: 1d
          JWT_RESET_TOKEN_EXPIRES_IN: 1h
          RATE_LIMIT_WINDOW_MS: 900000
          RATE_LIMIT_MAX: 100
          EMAIL_HOST: smtp.gmail.com
          EMAIL_PORT: 587
          EMAIL_USER: test@example.com
          EMAIL_PASS: test_password
          LOG_LEVEL: info

      - name: Build project
        if: github.event_name == 'push'
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            npm run build:prod
          else
            npm run build
          fi

      - name: Upload build artifacts
        if: github.event_name == 'push'
        uses: actions/upload-artifact@v4
        with:
          name: build-artifacts
          path: |
            dist/
            package.json
            package-lock.json
            prisma/
            swagger-spec.json
            ecosystem.prod.config.js
            ecosystem.staging.config.js

  deploy:
    needs: test
    if: github.event_name == 'push' && (github.ref == 'refs/heads/production' || github.ref == 'refs/heads/staging' || github.ref == 'refs/heads/feat/cicd')
    runs-on: ubuntu-latest
    # Modify deploy job concurrency to prevent cancellation during critical operations
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: false

    env:
      ROLLBACK_TIMEOUT: 100 # 30 seconds timeout for health check

    steps:
      - name: Set deployment variables
        run: |
          if [[ ${{ github.ref }} == 'refs/heads/production' ]]; then
            echo "ENVIRONMENT=production" >> $GITHUB_ENV
            echo "PM2_CONFIG=ecosystem.prod.config.js" >> $GITHUB_ENV
            echo "APP_PORT=5000" >> $GITHUB_ENV
          else
            echo "ENVIRONMENT=development" >> $GITHUB_ENV
            echo "PM2_CONFIG=ecosystem.staging.config.js" >> $GITHUB_ENV
            echo "APP_PORT=5001" >> $GITHUB_ENV
          fi

      - name: Download build artifacts
        uses: actions/download-artifact@v4
        with:
          name: build-artifacts
          path: build-artifacts

      - name: Install SSH key
        uses: webfactory/ssh-agent@v0.8.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_IP }} >> ~/.ssh/known_hosts

      - name: Setup deployment directory and check environment file
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
            # Create deployment directories
            mkdir -p ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}
            mkdir -p ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases
            mkdir -p ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/shared

            # Check if environment file exists
            ENV_FILE_PATH=${{ env.ENV_PATH }}/${{ env.ENVIRONMENT }}/${{ env.SERVICE_NAME }}/.env
            if [ ! -f \$ENV_FILE_PATH ]; then
              echo 'Environment file not found at '\$ENV_FILE_PATH
              echo 'Please ensure the environment file exists at the correct location.'
              exit 1
            fi
          "

      - name: Create release directory
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          RELEASE_ID: release_${{ github.sha }}
        run: |
          ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
            mkdir -p ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases/$RELEASE_ID
            mkdir -p ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases/$RELEASE_ID/logs
            chmod 755 ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases/$RELEASE_ID/logs
          "

      - name: Copy build artifacts and link environment file
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          RELEASE_ID: release_${{ github.sha }}
        run: |
          # Compress artifacts before transfer
          cd build-artifacts
          tar -czf ../artifacts.tar.gz .
          cd ..

          # Transfer compressed file
          scp artifacts.tar.gz ${{ env.CI_USER }}@${{ secrets.SERVER_IP }}:${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases/$RELEASE_ID/

          # Extract artifacts and setup environment file
          ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
            cd ${{ env.DEPLOY_PATH }}/${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}/releases/$RELEASE_ID
            tar -xzf artifacts.tar.gz
            rm artifacts.tar.gz

            # Create symbolic link to environment file
            ln -sf ${{ env.ENV_PATH }}/${{ env.ENVIRONMENT }}/${{ env.SERVICE_NAME }}/.env .env
          "

      - name: Deploy with PM2 and Handle Rollback
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
          RELEASE_ID: release_${{ github.sha }}
        run: |
          ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
            # Setup NVM and Node
            export NVM_DIR=\$HOME/.nvm
            [ -s \$NVM_DIR/nvm.sh ] && . \$NVM_DIR/nvm.sh || {
              echo \"Failed to source NVM\"
              exit 1
            }

            # Enable strict error handling
            set -e

            PM2_BINARY=\$(which pm2)
            if [ -z \"\$PM2_BINARY\" ]; then
              echo \"PM2 not found\"
              exit 1
            fi

            APP_NAME=\"${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}\"
            DEPLOY_BASE=\"${{ env.DEPLOY_PATH }}/\${APP_NAME}\"
            NEW_RELEASE=\"\${DEPLOY_BASE}/releases/$RELEASE_ID\"

            # Always deploy to green first for testing
            TARGET_COLOR=\"green\"
            echo \"Deploying to green environment for testing\"

            # Function to clean up failed deployment
            cleanup_failed_deployment() {
              # local error_message=\$1
              # echo \"❌ Deployment failed: \${error_message}\"

              # # Stop and remove green deployment if it exists
              # \$PM2_BINARY delete \"\${APP_NAME}-green\" 2>/dev/null || true

              # # Remove the failed release
              # rm -rf \"\${NEW_RELEASE}\"
              # rm -rf \"\${DEPLOY_BASE}/green\"

              # # Ensure blue is still running and linked as current
              # if [ -d \"\${DEPLOY_BASE}/blue\" ]; then
              #   ln -sfn \"\${DEPLOY_BASE}/blue\" \"\${DEPLOY_BASE}/current\"
              # fi

              # exit 1
            }

            # Setup green directory for testing
            TARGET_DIR=\"\${DEPLOY_BASE}/green\"
            mkdir -p \"\${TARGET_DIR}\"

            # Create release directory
            mkdir -p \"\${NEW_RELEASE}\"
            cd \"\${NEW_RELEASE}\" || cleanup_failed_deployment \"Failed to change directory to \${NEW_RELEASE}\"

            # Link environment file
            ln -sf \"${{ env.ENV_PATH }}/${{ env.ENVIRONMENT }}/${{ env.SERVICE_NAME }}/.env\" .env

            # Calculate ports (green always uses offset ports)
            BLUE_PORT=${{ env.APP_PORT }}
            GREEN_PORT=\$((BLUE_PORT + 1))
            BLUE_HEALTH_PORT=\$((BLUE_PORT + 100))
            GREEN_HEALTH_PORT=\$((GREEN_PORT + 100))

            # Update environment file with green port
            sed -i \"s/^PORT=.*/PORT=\${GREEN_PORT}/\" .env
            sed -i \"s/^HEALTH_PORT=.*/HEALTH_PORT=\${GREEN_HEALTH_PORT}/\" .env

            echo \"Starting green deployment on port \${GREEN_PORT} (health check on \${GREEN_HEALTH_PORT})\"

            # Start new instance in green
            if ! SERVICE_NAME=\"\${APP_NAME}-green\" \$PM2_BINARY start ${{ env.PM2_CONFIG }} --update-env; then
              cleanup_failed_deployment \"Failed to start application\"
            fi

            # Save PM2 configuration
            \$PM2_BINARY save || cleanup_failed_deployment \"Failed to save PM2 configuration\"

            # Monitor health of green deployment
            echo \"Monitoring green deployment health...\"
            start_time=\$(date +%s)
            timeout=${{ env.ROLLBACK_TIMEOUT }}
            deployment_successful=false

            while true; do
              current_time=\$(date +%s)
              elapsed=\$((current_time - start_time))

              if [ \$elapsed -ge \$timeout ]; then
                echo \"❌ Health check timeout reached\"
                cleanup_failed_deployment \"Health check timeout\"
              fi

              # Check application health on green
              if curl -s \"http://localhost:\${GREEN_HEALTH_PORT}/health\" | grep -q \"ok\"; then
                # Verify green instance is running
                RUNNING_INSTANCES=\$(\$PM2_BINARY prettylist | grep -c \"online\")
                EXPECTED_INSTANCES=\$(\$PM2_BINARY prettylist | grep -c \"\${APP_NAME}-green\")

                if [ \"\$RUNNING_INSTANCES\" -eq \"\$EXPECTED_INSTANCES\" ]; then
                  echo \"✅ Green deployment is healthy\"
                  deployment_successful=true
                  break
                fi
              fi

              # Check for critical errors in logs
              if \$PM2_BINARY logs \"\${APP_NAME}-green\" --lines 100 --nostream | grep -q \"FATAL ERROR\"; then
                echo \"❌ Critical error detected in logs\"
                cleanup_failed_deployment \"Critical error in application logs\"
              fi

              sleep 2
            done

            if [ \"\$deployment_successful\" = true ]; then
              echo \"Green deployment successful, promoting to blue...\"

              # Stop blue instance if it exists
              \$PM2_BINARY delete \"\${APP_NAME}-blue\" 2>/dev/null || true

              # Update environment file with blue port
              sed -i \"s/^PORT=.*/PORT=\${BLUE_PORT}/\" .env
              sed -i \"s/^HEALTH_PORT=.*/HEALTH_PORT=\${BLUE_HEALTH_PORT}/\" .env

              # Start blue instance
              if ! SERVICE_NAME=\"\${APP_NAME}-blue\" \$PM2_BINARY start ${{ env.PM2_CONFIG }} --update-env; then
                cleanup_failed_deployment \"Failed to start blue instance\"
              fi

              # Update symlinks
              ln -sfn \"\${NEW_RELEASE}\" \"\${DEPLOY_BASE}/blue\"
              ln -sfn \"\${DEPLOY_BASE}/blue\" \"\${DEPLOY_BASE}/current\"

              # Stop green instance
              \$PM2_BINARY delete \"\${APP_NAME}-green\" || true
              rm -rf \"\${DEPLOY_BASE}/green\"

              \$PM2_BINARY save

              echo \"✅ Successfully promoted green deployment to blue\"
              exit 0
            else
              cleanup_failed_deployment \"Deployment verification failed\"
            fi"

      - name: Verify Final Deployment State
        if: success()
        env:
          SERVER_IP: ${{ secrets.SERVER_IP }}
        run: |
          ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
            export NVM_DIR=\$HOME/.nvm
            [ -s \$NVM_DIR/nvm.sh ] && \. \$NVM_DIR/nvm.sh
            PM2_BINARY=\$(which pm2)

            echo 'Final deployment state:'
            \$PM2_BINARY list
            \$PM2_BINARY logs ${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }} --lines 20 --nostream
          "

  # cleanup:
  #   if: failure()
  #   needs: [deploy]
  #   runs-on: ubuntu-latest
  #   steps:
  #     - name: Cleanup Failed Deployment
  #       env:
  #         SERVER_IP: ${{ secrets.SERVER_IP }}
  #       run: |
  #         ssh ${{ env.CI_USER }}@${{ secrets.SERVER_IP }} "
  #           export NVM_DIR=\$HOME/.nvm
  #           [ -s \$NVM_DIR/nvm.sh ] && \. \$NVM_DIR/nvm.sh

  #           APP_NAME='${{ env.SERVICE_NAME }}-${{ env.ENVIRONMENT }}'
  #           DEPLOY_DIR=${{ env.DEPLOY_PATH }}/\$APP_NAME
  #           FAILED_RELEASE=\$DEPLOY_DIR/releases/release_${{ github.sha }}

  #           # Remove failed release directory if it exists
  #           if [ -d \$FAILED_RELEASE ]; then
  #             echo 'Removing failed deployment directory...'
  #             rm -rf \$FAILED_RELEASE
  #           fi

  #           # Check for and restore database if needed
  #           BACKUP_FILE=\$(find \$FAILED_RELEASE -name 'pre_deploy_*.sql' -type f -print -quit)
  #           if [ -n \"\$BACKUP_FILE\" ]; then
  #             echo 'Found database backup, restoring...'
  #             DB_URL=\$(grep DATABASE_URL \$DEPLOY_DIR/current/.env | cut -d '=' -f2- | tr -d '\"')
  #             psql \$DB_URL < \$BACKUP_FILE
  #             rm \$BACKUP_FILE
  #           fi

  #           # Ensure service is running with last known good version
  #           PM2_BINARY=\$(which pm2)
  #           if \$PM2_BINARY describe \$APP_NAME > /dev/null; then
  #             echo 'Ensuring service is running with last known good version...'
  #             cd \$DEPLOY_DIR/current
  #             SERVICE_NAME=\$APP_NAME \$PM2_BINARY restart \$APP_NAME --update-env
  #             \$PM2_BINARY save
  #           fi
  #         "
